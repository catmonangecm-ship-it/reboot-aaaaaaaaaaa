<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Trading IA Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {
            background: linear-gradient(to bottom right, #0f172a, #581c87, #0f172a);
            min-height: 100vh;
        }
        .animate-spin { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .ai-thinking {
            background: linear-gradient(90deg, #8b5cf6, #ec4899, #8b5cf6);
            background-size: 200% 100%;
            animation: gradient 2s ease infinite;
        }
        @keyframes gradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
    </style>
</head>
<body class="text-white p-4 md:p-6">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-8">
            <div>
                <h1 class="text-3xl md:text-4xl font-bold bg-gradient-to-r from-purple-400 via-pink-500 to-purple-400 bg-clip-text text-transparent">
                    ü§ñ Bot Trading IA Pro
                </h1>
                <p class="text-gray-400 mt-2">Intelligence Artificielle ‚Ä¢ BSC ‚Ä¢ BTC/ETH/BNB</p>
            </div>
            
            <div class="flex gap-3">
                <button onclick="connectWallet()" id="connectBtn" class="flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600">
                    <span>üëõ</span>
                    <span id="walletText">MetaMask</span>
                </button>
                <button onclick="togglePrivateKeyModal()" class="flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600">
                    <span>üîë</span>
                    <span>Cl√© Priv√©e</span>
                </button>
            </div>
        </div>

        <!-- Private Key Modal -->
        <div id="privateKeyModal" class="hidden fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div class="bg-slate-800 border-2 border-purple-500 rounded-2xl p-6 max-w-md w-full">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-purple-400">üîë Connexion par Cl√© Priv√©e</h3>
                    <button onclick="togglePrivateKeyModal()" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                </div>
                
                <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4 mb-4">
                    <p class="text-yellow-400 text-sm flex items-start gap-2">
                        <span>‚ö†Ô∏è</span>
                        <span>Ne partagez jamais votre cl√© priv√©e. Assurez-vous d'√™tre seul et sur un appareil s√©curis√©.</span>
                    </p>
                </div>
                
                <div class="mb-4">
                    <label class="block text-sm text-gray-400 mb-2">Cl√© priv√©e (avec ou sans 0x)</label>
                    <input type="password" id="privateKeyInput" placeholder="0x..." class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-purple-400 font-mono text-sm">
                </div>
                
                <button onclick="connectWithPrivateKey()" class="w-full px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 rounded-lg font-semibold transition-all">
                    Se connecter
                </button>
                
                <div class="mt-4 text-xs text-gray-400">
                    <p class="mb-2">üí° O√π trouver ma cl√© priv√©e dans MetaMask ?</p>
                    <p>1. Ouvrez MetaMask</p>
                    <p>2. Cliquez sur les 3 points</p>
                    <p>3. D√©tails du compte ‚Üí Exporter la cl√© priv√©e</p>
                    <p>4. Entrez votre mot de passe MetaMask</p>
                </div>
            </div>
        </div>

        <!-- AI Status -->
        <div id="aiStatus" class="bg-gradient-to-r from-purple-500/20 to-pink-500/20 border-2 border-purple-500 rounded-xl p-6 mb-6 hidden">
            <div class="flex items-center gap-4 mb-4">
                <div class="relative">
                    <div class="w-16 h-16 rounded-full bg-gradient-to-r from-purple-500 to-pink-500 flex items-center justify-center text-3xl">
                        ü§ñ
                    </div>
                    <div id="aiIndicator" class="absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full animate-pulse"></div>
                </div>
                <div>
                    <h3 class="text-xl font-bold">Assistant IA Claude</h3>
                    <p class="text-sm text-gray-400">Analyse en temps r√©el ‚Ä¢ Pr√©dictions avanc√©es</p>
                </div>
            </div>
            
            <div id="aiThinking" class="bg-slate-700/50 rounded-lg p-4 mb-4 hidden">
                <div class="flex items-center gap-3">
                    <div class="ai-thinking w-2 h-2 rounded-full"></div>
                    <p class="text-sm text-purple-300 italic">L'IA analyse les donn√©es du march√©...</p>
                </div>
            </div>
            
            <div id="aiRecommendation" class="bg-slate-700/50 rounded-lg p-4 hidden">
                <p class="text-purple-300 font-bold mb-2">üí° Recommandation IA</p>
                <p id="aiRecommendationText" class="text-sm text-gray-300"></p>
                <div class="mt-3 flex gap-2">
                    <span id="aiConfidence" class="px-3 py-1 bg-purple-500/30 rounded-full text-xs font-semibold"></span>
                    <span id="aiAction" class="px-3 py-1 rounded-full text-xs font-semibold"></span>
                </div>
            </div>
        </div>

        <!-- Crypto Selector -->
        <div id="cryptoSelector" class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6 mb-6 hidden">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-2">Cryptomonnaie</label>
                    <select id="cryptoSelect" onchange="changeCrypto()" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-purple-400 text-lg font-semibold cursor-pointer">
                        <option value="BTCUSDT">BTC - Bitcoin üíé</option>
                        <option value="ETHUSDT">ETH - Ethereum üíé</option>
                        <option value="BNBUSDT">BNB - Binance Coin üíé</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm text-gray-400 mb-2">Mode de Trading</label>
                    <select id="tradingMode" onchange="changeTradingMode()" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-purple-400 text-lg font-semibold cursor-pointer">
                        <option value="simulation">üéÆ Simulation IA</option>
                        <option value="real">üíé R√©el (PancakeSwap)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Capital Section -->
        <div id="capitalSection" class="bg-gradient-to-r from-purple-400/20 to-pink-500/20 border-2 border-purple-400 rounded-xl p-6 mb-6 hidden">
            <h3 class="text-xl font-bold mb-4">üéØ Capital de trading</h3>
            <div class="flex gap-4 mb-3">
                <input type="number" id="capitalInput" placeholder="Ex: 100" step="10" class="flex-1 bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-purple-400">
                <button onclick="setCapital()" class="px-8 py-3 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 rounded-lg font-semibold transition-all">
                    Valider
                </button>
            </div>
        </div>

        <!-- Stats Cards -->
        <div id="statsCards" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8 hidden">
            <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
                <p class="text-gray-400 text-xs">Capital</p>
                <p class="text-xl font-bold mt-1 text-purple-400">$<span id="capitalDisplay">0</span></p>
            </div>
            
            <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
                <p class="text-gray-400 text-xs">Prix <span id="cryptoName">BTC</span></p>
                <p class="text-xl font-bold mt-1">$<span id="currentPrice">...</span></p>
            </div>
            
            <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
                <p class="text-gray-400 text-xs">Profit IA</p>
                <p class="text-xl font-bold mt-1 text-green-400">$<span id="profitDisplay">0.00</span></p>
            </div>
            
            <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
                <p class="text-gray-400 text-xs">Pr√©cision IA</p>
                <p class="text-xl font-bold mt-1 text-purple-400"><span id="aiAccuracy">0</span>%</p>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Column -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Chart -->
                <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">üìà Analyse IA</h2>
                        <div class="text-sm text-gray-400">
                            <span id="chartCrypto">BTC</span>/USDT
                        </div>
                    </div>
                    <div class="h-64">
                        <canvas id="tradingChart"></canvas>
                    </div>
                </div>

                <!-- Trade History -->
                <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold">ü§ñ Trades IA</h2>
                        <button onclick="toggleBot()" id="toggleBotBtn" disabled class="flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-gray-600 cursor-not-allowed">
                            <span id="botIcon">‚ñ∂Ô∏è</span>
                            <span id="botText">D√©marrer IA</span>
                        </button>
                    </div>
                    <div id="tradesContainer">
                        <div class="text-center py-8 text-gray-400">
                            <span class="text-4xl">ü§ñ</span>
                            <p>L'IA attend vos instructions</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div class="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6">
                <h2 class="text-2xl font-bold mb-4">‚öôÔ∏è Param√®tres IA</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Agressivit√© IA</label>
                        <select id="aiAggression" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-purple-400">
                            <option value="conservative">üê¢ Conservateur (S√ªr)</option>
                            <option value="moderate" selected>‚öñÔ∏è Mod√©r√© (√âquilibr√©)</option>
                            <option value="aggressive">üöÄ Agressif (Risqu√©)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">% par trade</label>
                        <input type="number" id="tradePercent" value="10" min="1" max="100" onchange="updateTradeAmount()" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-purple-400">
                        <p class="text-xs text-gray-400 mt-1">Montant: $<span id="tradeAmount">0</span></p>
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Intervalle d'analyse IA</label>
                        <select id="aiInterval" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-purple-400">
                            <option value="5000">‚ö° Rapide (5s)</option>
                            <option value="15000" selected>‚öñÔ∏è Normal (15s)</option>
                            <option value="30000">üê¢ Lent (30s)</option>
                        </select>
                    </div>

                    <div class="bg-gradient-to-r from-green-500/10 to-emerald-500/10 border border-green-500/30 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-2">
                            <label class="text-sm font-semibold text-green-400">üîã Mode Veille Actif</label>
                            <div class="relative">
                                <input type="checkbox" id="wakeLockToggle" onchange="toggleWakeLock()" class="sr-only peer">
                                <div class="w-11 h-6 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
                            </div>
                        </div>
                        <p class="text-xs text-gray-400">Emp√™che l'√©cran de se mettre en veille. Le bot continuera de trader m√™me si vous minimisez l'onglet.</p>
                        <p id="wakeLockStatus" class="text-xs text-gray-400 mt-2">Status: <span class="text-red-400">D√©sactiv√©</span></p>
                    </div>
                </div>

                <div class="mt-6 p-4 bg-purple-400/10 border border-purple-400/30 rounded-lg">
                    <div class="flex gap-2">
                        <span class="text-purple-400">ü§ñ</span>
                        <div class="text-sm text-gray-300">
                            <p class="font-semibold text-purple-400">Statut IA</p>
                            <p>Wallet: <span id="walletStatus">üî¥ Non connect√©</span></p>
                            <p>Position: <span id="positionStatus">‚ö™ Aucune</span></p>
                            <p>Trades IA: <span id="aiTrades">0</span></p>
                            <p>Taux r√©ussite: <span id="successRate">0%</span></p>
                        </div>
                    </div>
                </div>

                <div class="mt-4 p-4 bg-blue-400/10 border border-blue-400/30 rounded-lg">
                    <div class="flex gap-2">
                        <span class="text-blue-400">üí°</span>
                        <div class="text-xs text-gray-300">
                            <p class="font-semibold text-blue-400">Comment √ßa marche?</p>
                            <p class="mt-2">L'IA analyse en temps r√©el:</p>
                            <p>‚Ä¢ Prix et volatilit√©</p>
                            <p>‚Ä¢ Tendances du march√©</p>
                            <p>‚Ä¢ Volumes d'√©change</p>
                            <p>‚Ä¢ Indicateurs techniques</p>
                        </div>
                    </div>
                </div>

                <div class="mt-4 p-4 bg-orange-400/10 border border-orange-400/30 rounded-lg">
                    <div class="flex gap-2">
                        <span class="text-orange-400">‚ö°</span>
                        <div class="text-xs text-gray-300">
                            <p class="font-semibold text-orange-400">Mode Veille</p>
                            <p class="mt-2">‚úÖ Bot actif en arri√®re-plan</p>
                            <p>‚úÖ Trading 24/7 automatique</p>
                            <p>‚úÖ Notifications sonores</p>
                            <p>‚úÖ Auto-sauvegarde</p>
                            <p class="mt-2 text-yellow-400">üí° Gardez l'onglet ouvert</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
        const USDT_CONTRACT = '0x55d398326f99059fF775485246999027B3197955';
        const WBNB_CONTRACT = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';
        const BSC_RPC = 'https://bsc-dataseed1.binance.org';
        
        const TOKEN_ADDRESSES = {
            'BTCUSDT': '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c',
            'ETHUSDT': '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',
            'BNBUSDT': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'
        };

        // PancakeSwap Router ABI (fonctions essentielles)
        const ROUTER_ABI = [
            'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
            'function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)',
            'function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
            'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
        ];

        // ERC20 ABI (fonctions essentielles)
        const ERC20_ABI = [
            'function approve(address spender, uint256 amount) public returns (bool)',
            'function allowance(address owner, address spender) public view returns (uint256)',
            'function balanceOf(address account) public view returns (uint256)',
            'function decimals() public view returns (uint8)'
        ];

        let state = {
            account: null,
            isConnected: false,
            selectedCrypto: 'BTCUSDT',
            currentPrice: null,
            priceHistory: [],
            tradingCapital: 0,
            capitalSet: false,
            tradingMode: 'simulation',
            botRunning: false,
            trades: [],
            portfolio: { profit: 0, profitPercent: 0 },
            currentPosition: null,
            lastBuyPrice: 0,
            positionAmount: 0,
            aiStats: { totalTrades: 0, successfulTrades: 0, accuracy: 0 },
            provider: null,
            wallet: null,
            connectionType: null,
            realTrading: {
                approvedTokens: {},
                pendingTx: null,
                lastGasPrice: null
            },
            binance: {
                apiKey: null,
                secretKey: null,
                connected: false
            }
        };

        let ws = null, botInterval = null, tradingChart = null;
        let wakeLock = null;
        let keepAliveInterval = null;

        // Initialization
        window.addEventListener('DOMContentLoaded', () => {
            console.log('ü§ñ Bot IA charg√©');
            initChart();
            connectWebSocket();
            initVisibilityListener();
            initKeepAlive();
        });

        // Wallet Connection
        async function connectWallet() {
            if (!window.ethereum) {
                alert('‚ùå MetaMask requis');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                state.account = accounts[0];
                state.provider = new ethers.providers.Web3Provider(window.ethereum);
                state.isConnected = true;
                state.connectionType = 'metamask';
                
                console.log('‚úÖ Wallet:', state.account);
                updateUI();
            } catch (error) {
                alert('Erreur: ' + error.message);
            }
        }

        function togglePrivateKeyModal() {
            const modal = document.getElementById('privateKeyModal');
            modal.classList.toggle('hidden');
            if (!modal.classList.contains('hidden')) {
                document.getElementById('privateKeyInput').value = '';
            }
        }

        async function connectWithPrivateKey() {
            const privateKeyInput = document.getElementById('privateKeyInput').value.trim();
            
            if (!privateKeyInput) {
                alert('‚ùå Veuillez entrer une cl√© priv√©e');
                return;
            }

            try {
                // Add 0x prefix if not present
                let privateKey = privateKeyInput;
                if (!privateKey.startsWith('0x')) {
                    privateKey = '0x' + privateKey;
                }

                // Validate private key format
                if (privateKey.length !== 66) {
                    alert('‚ùå Cl√© priv√©e invalide (doit faire 64 caract√®res sans 0x)');
                    return;
                }

                // Create provider
                state.provider = new ethers.providers.JsonRpcProvider(BSC_RPC);
                
                // Create wallet from private key
                state.wallet = new ethers.Wallet(privateKey, state.provider);
                state.account = state.wallet.address;
                state.isConnected = true;
                state.connectionType = 'privatekey';
                
                console.log('‚úÖ Wallet connect√©:', state.account);
                
                // Close modal
                togglePrivateKeyModal();
                
                // Update UI
                updateUI();
                
                alert('‚úÖ Connexion r√©ussie!\n\nAdresse: ' + state.account.slice(0, 6) + '...' + state.account.slice(-4));
            } catch (error) {
                console.error('Erreur connexion:', error);
                alert('‚ùå Erreur: Cl√© priv√©e invalide\n\n' + error.message);
            }
        }

        function updateUI() {
            if (state.isConnected) {
                const connectionBadge = state.connectionType === 'privatekey' ? 'üîë' : 'üëõ';
                document.getElementById('connectBtn').className = 
                    'flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all bg-green-600 hover:bg-green-700';
                document.getElementById('walletText').textContent = 
                    `${connectionBadge} ${state.account.slice(0, 6)}...${state.account.slice(-4)}`;
                document.getElementById('walletStatus').innerHTML = 
                    `üü¢ ${state.connectionType === 'privatekey' ? 'Cl√© priv√©e' : 'MetaMask'}`;
                
                document.getElementById('aiStatus').classList.remove('hidden');
                document.getElementById('cryptoSelector').classList.remove('hidden');
                document.getElementById('capitalSection').classList.remove('hidden');
            }
            
            if (state.capitalSet) {
                document.getElementById('capitalSection').classList.add('hidden');
                document.getElementById('statsCards').classList.remove('hidden');
                document.getElementById('capitalDisplay').textContent = state.tradingCapital.toFixed(2);
                document.getElementById('toggleBotBtn').disabled = false;
                document.getElementById('toggleBotBtn').className = 
                    'flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600';
                updateTradeAmount();
            }
        }

        function setCapital() {
            const capital = parseFloat(document.getElementById('capitalInput').value);
            if (!capital || capital <= 0) {
                alert('‚ùå Montant invalide');
                return;
            }
            
            state.tradingCapital = capital;
            state.capitalSet = true;
            updateUI();
            alert(`‚úÖ Capital d√©fini: ${capital} USDT\n\nL'IA est pr√™te √† trader !`);
        }

        function updateTradeAmount() {
            const percent = parseFloat(document.getElementById('tradePercent').value);
            const amount = (state.tradingCapital * percent / 100).toFixed(2);
            document.getElementById('tradeAmount').textContent = amount;
        }

        // WebSocket
        function connectWebSocket() {
            if (ws) ws.close();
            
            const symbol = state.selectedCrypto.toLowerCase();
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@ticker`);
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                state.currentPrice = parseFloat(data.c);
                
                state.priceHistory.push(state.currentPrice);
                if (state.priceHistory.length > 100) state.priceHistory.shift();
                
                document.getElementById('currentPrice').textContent = state.currentPrice.toFixed(2);
                document.getElementById('cryptoName').textContent = state.selectedCrypto.replace('USDT', '');
                
                if (state.priceHistory.length % 5 === 0) updateChart();
            };
        }

        function changeCrypto() {
            state.selectedCrypto = document.getElementById('cryptoSelect').value;
            state.priceHistory = [];
            connectWebSocket();
            document.getElementById('chartCrypto').textContent = state.selectedCrypto.replace('USDT', '');
        }

        function changeTradingMode() {
            state.tradingMode = document.getElementById('tradingMode').value;
            
            if (state.tradingMode === 'real-pancake') {
                const confirmed = confirm(
                    '‚ö†Ô∏è ATTENTION - MODE TRADING R√âEL PANCAKESWAP ‚ö†Ô∏è\n\n' +
                    '‚úÖ Vous allez effectuer de VRAIS trades sur PancakeSwap\n' +
                    '‚úÖ De l\'ARGENT R√âEL sera √©chang√©\n' +
                    '‚úÖ Des frais de gas seront pay√©s en BNB\n' +
                    '‚úÖ Les transactions sont IRR√âVERSIBLES\n' +
                    '‚úÖ Risque de PERTE financi√®re\n\n' +
                    '√ätes-vous s√ªr de vouloir continuer ?'
                );
                
                if (!confirmed) {
                    document.getElementById('tradingMode').value = 'simulation';
                    state.tradingMode = 'simulation';
                    return;
                }
                
                if (!state.isConnected) {
                    alert('‚ùå Veuillez connecter votre wallet d\'abord');
                    document.getElementById('tradingMode').value = 'simulation';
                    state.tradingMode = 'simulation';
                    return;
                }
                
                alert('üíé Mode PancakeSwap ACTIV√â ! Assurez-vous d\'avoir du BNB pour les frais de gas.');
            }
            else if (state.tradingMode === 'real-binance') {
                const confirmed = confirm(
                    '‚ö†Ô∏è ATTENTION - MODE TRADING R√âEL BINANCE ‚ö†Ô∏è\n\n' +
                    '‚úÖ Vous allez effectuer de VRAIS trades sur Binance Spot\n' +
                    '‚úÖ De l\'ARGENT R√âEL sera √©chang√©\n' +
                    '‚úÖ Des frais de trading seront appliqu√©s (0.1%)\n' +
                    '‚úÖ Les transactions sont IRR√âVERSIBLES\n' +
                    '‚úÖ Risque de PERTE financi√®re\n\n' +
                    '√ätes-vous s√ªr de vouloir continuer ?'
                );
                
                if (!confirmed) {
                    document.getElementById('tradingMode').value = 'simulation';
                    state.tradingMode = 'simulation';
                    return;
                }
                
                if (!state.binance.connected) {
                    alert('‚ùå Veuillez connecter votre Binance API d\'abord');
                    document.getElementById('tradingMode').value = 'simulation';
                    state.tradingMode = 'simulation';
                    return;
                }
                
                alert('üü° Mode Binance Spot ACTIV√â ! Les trades seront ex√©cut√©s via l\'API Binance.');
            }
        }

        // Connect Binance API
        async function connectBinanceAPI() {
            const apiKey = document.getElementById('binanceApiKey').value.trim();
            const secretKey = document.getElementById('binanceSecretKey').value.trim();

            if (!apiKey || !secretKey) {
                alert('‚ùå Veuillez entrer vos cl√©s API Binance');
                return;
            }

            try {
                // Test API connection
                const timestamp = Date.now();
                const testUrl = `https://api.binance.com/api/v3/account?timestamp=${timestamp}`;
                
                // Create signature
                const signature = await createBinanceSignature(secretKey, `timestamp=${timestamp}`);
                
                const response = await fetch(`${testUrl}&signature=${signature}`, {
                    headers: {
                        'X-MBX-APIKEY': apiKey
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    
                    state.binance.apiKey = apiKey;
                    state.binance.secretKey = secretKey;
                    state.binance.connected = true;

                    alert(`‚úÖ Binance API connect√©e avec succ√®s!\n\nCompte: ${data.accountType}\nBalance disponible pour trading.`);
                    
                    console.log('‚úÖ Binance API connect√©e');
                    console.log('Balances:', data.balances.filter(b => parseFloat(b.free) > 0));
                } else {
                    const error = await response.json();
                    throw new Error(error.msg || 'Erreur API');
                }
            } catch (error) {
                alert(`‚ùå Erreur connexion Binance API:\n\n${error.message}\n\nV√©rifiez vos cl√©s API.`);
                console.error('Erreur Binance API:', error);
            }
        }

        // Create Binance Signature
        async function createBinanceSignature(secret, queryString) {
            const encoder = new TextEncoder();
            const data = encoder.encode(queryString);
            const key = encoder.encode(secret);
            
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                key,
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, data);
            const hashArray = Array.from(new Uint8Array(signature));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Chart
        function initChart() {
            const ctx = document.getElementById('tradingChart').getContext('2d');
            tradingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Prix',
                        data: [],
                        borderColor: 'rgb(168, 85, 247)',
                        backgroundColor: 'rgba(168, 85, 247, 0.1)',
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 2
                    }, {
                        label: 'Achat IA',
                        data: [],
                        backgroundColor: 'rgb(34, 197, 94)',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false
                    }, {
                        label: 'Vente IA',
                        data: [],
                        backgroundColor: 'rgb(239, 68, 68)',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false,
                        rotation: 180
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: 'rgb(156, 163, 175)' } } },
                    scales: {
                        x: { grid: { color: 'rgba(75, 85, 99, 0.3)' }, ticks: { color: 'rgb(156, 163, 175)' } },
                        y: { grid: { color: 'rgba(75, 85, 99, 0.3)' }, ticks: { color: 'rgb(156, 163, 175)' } }
                    }
                }
            });
        }

        function updateChart() {
            if (!tradingChart || state.priceHistory.length === 0) return;
            
            const prices = state.priceHistory.slice(-50);
            const labels = prices.map((_, i) => {
                const time = new Date(Date.now() - (50 - i - 1) * 5000);
                return time.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            });
            
            tradingChart.data.labels = labels;
            tradingChart.data.datasets[0].data = prices;
            tradingChart.update('none');
        }

        // AI Trading Bot
        function toggleBot() {
            if (!state.capitalSet) {
                alert('‚ùå D√©finissez le capital');
                return;
            }
            
            state.botRunning = !state.botRunning;
            
            if (state.botRunning) {
                startBot();
            } else {
                stopBot();
            }
            
            updateBotButton();
        }

        function updateBotButton() {
            const btn = document.getElementById('toggleBotBtn');
            if (state.botRunning) {
                btn.className = 'flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-red-600 hover:bg-red-700';
                document.getElementById('botIcon').textContent = '‚è∏Ô∏è';
                document.getElementById('botText').textContent = 'Arr√™ter IA';
            } else {
                btn.className = 'flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600';
                document.getElementById('botIcon').textContent = '‚ñ∂Ô∏è';
                document.getElementById('botText').textContent = 'D√©marrer IA';
            }
        }

        function startBot() {
            console.log('ü§ñ IA activ√©e');
            document.getElementById('aiIndicator').className = 'absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full animate-pulse';
            
            const interval = parseInt(document.getElementById('aiInterval').value);
            
            botInterval = setInterval(() => {
                if (state.priceHistory.length < 20) return;
                
                analyzeWithAI();
            }, interval);
        }

        function stopBot() {
            if (botInterval) {
                clearInterval(botInterval);
                botInterval = null;
                console.log('ü§ñ IA d√©sactiv√©e');
                document.getElementById('aiIndicator').className = 'absolute -top-1 -right-1 w-4 h-4 bg-gray-500 rounded-full';
            }
        }

        async function analyzeWithAI() {
            // Show thinking animation
            document.getElementById('aiThinking').classList.remove('hidden');
            
            // Simulate AI analysis
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Get AI decision
            const decision = getAIDecision();
            
            // Hide thinking
            document.getElementById('aiThinking').classList.add('hidden');
            
            // Show recommendation
            showAIRecommendation(decision);
            
            // Execute if confidence high enough
            if (decision.confidence > 0.75 && decision.signal) {
                executeTrade(decision.signal, decision);
            }
        }

        function getAIDecision() {
            const aggression = document.getElementById('aiAggression').value;
            const prices = state.priceHistory.slice(-20);
            
            // Simple AI logic
            const recentChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;
            const volatility = calculateVolatility(prices);
            const trend = calculateTrend(prices);
            
            let signal = null;
            let confidence = 0.5;
            let reason = '';
            
            // Conservative strategy
            if (aggression === 'conservative') {
                if (!state.currentPosition && recentChange < -2 && trend === 'down') {
                    signal = 'BUY';
                    confidence = 0.8;
                    reason = 'Prix en baisse significative, bon point d\'entr√©e';
                } else if (state.currentPosition && recentChange > 2) {
                    signal = 'SELL';
                    confidence = 0.85;
                    reason = 'Profit s√©curis√©, position ferm√©e';
                }
            }
            // Moderate strategy
            else if (aggression === 'moderate') {
                if (!state.currentPosition && recentChange < -1.5 && volatility < 3) {
                    signal = 'BUY';
                    confidence = 0.75;
                    reason = 'Opportunit√© d\'achat d√©tect√©e';
                } else if (state.currentPosition) {
                    const profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                    if (profitPercent > 1.5 || profitPercent < -1) {
                        signal = 'SELL';
                        confidence = 0.8;
                        reason = profitPercent > 0 ? 'Take profit atteint' : 'Stop loss activ√©';
                    }
                }
            }
            // Aggressive strategy
            else {
                if (!state.currentPosition && recentChange < -1) {
                    signal = 'BUY';
                    confidence = 0.7;
                    reason = 'Signal d\'achat agressif';
                } else if (state.currentPosition) {
                    const profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                    if (profitPercent > 1 || profitPercent < -0.5) {
                        signal = 'SELL';
                        confidence = 0.75;
                        reason = profitPercent > 0 ? 'Profit rapide' : 'Stop loss rapide';
                    }
                }
            }
            
            return { signal, confidence, reason, recentChange, volatility, trend };
        }

        function calculateVolatility(prices) {
            const changes = prices.slice(1).map((p, i) => Math.abs(p - prices[i]));
            return changes.reduce((a, b) => a + b, 0) / changes.length;
        }

        function calculateTrend(prices) {
            const start = prices[0];
            const end = prices[prices.length - 1];
            const change = ((end - start) / start) * 100;
            if (change > 0.5) return 'up';
            if (change < -0.5) return 'down';
            return 'sideways';
        }

        function showAIRecommendation(decision) {
            const recDiv = document.getElementById('aiRecommendation');
            const textEl = document.getElementById('aiRecommendationText');
            const confEl = document.getElementById('aiConfidence');
            const actionEl = document.getElementById('aiAction');
            
            recDiv.classList.remove('hidden');
            
            if (decision.signal) {
                textEl.textContent = `${decision.reason} (Changement: ${decision.recentChange.toFixed(2)}%)`;
                confEl.textContent = `Confiance: ${(decision.confidence * 100).toFixed(0)}%`;
                confEl.className = `px-3 py-1 ${decision.confidence > 0.8 ? 'bg-green-500/30 text-green-300' : 'bg-yellow-500/30 text-yellow-300'} rounded-full text-xs font-semibold`;
                
                if (decision.signal === 'BUY') {
                    actionEl.textContent = 'üü¢ ACHAT';
                    actionEl.className = 'px-3 py-1 bg-green-500/30 text-green-300 rounded-full text-xs font-semibold';
                } else {
                    actionEl.textContent = 'üî¥ VENTE';
                    actionEl.className = 'px-3 py-1 bg-red-500/30 text-red-300 rounded-full text-xs font-semibold';
                }
            } else {
                textEl.textContent = 'Aucune opportunit√© d√©tect√©e. L\'IA surveille le march√©...';
                confEl.textContent = 'Attente';
                confEl.className = 'px-3 py-1 bg-gray-500/30 text-gray-300 rounded-full text-xs font-semibold';
                actionEl.textContent = '‚ö™ HOLD';
                actionEl.className = 'px-3 py-1 bg-gray-500/30 text-gray-300 rounded-full text-xs font-semibold';
            }
        }

        function executeTrade(tradeType, decision) {
            const percent = parseFloat(document.getElementById('tradePercent').value);
            const amount = (state.tradingCapital * percent / 100);
            
            console.log(`ü§ñ IA ex√©cute: ${tradeType} - ${amount.toFixed(2)} USDT`);
            console.log(`üìä Raison: ${decision.reason}`);
            console.log(`üéØ Confiance: ${(decision.confidence * 100).toFixed(0)}%`);
            
            // Mode R√âEL BINANCE
            if (state.tradingMode === 'real-binance') {
                executeRealBinanceTrade(tradeType, amount, decision);
            }
            // Mode R√âEL PANCAKESWAP
            else if (state.tradingMode === 'real-pancake') {
                executeRealTrade(tradeType, amount, decision);
            } 
            // Mode SIMULATION
            else {
                executeSimulatedTrade(tradeType, amount, decision);
            }
        }

        // SIMULATION MODE
        function executeSimulatedTrade(tradeType, amount, decision) {
            let profit = 0;
            let profitPercent = 0;
            let success = false;
            
            if (tradeType === 'BUY') {
                state.currentPosition = 'BUY';
                state.lastBuyPrice = state.currentPrice;
                state.positionAmount = amount;
                document.getElementById('positionStatus').innerHTML = 'üü¢ Long';
            } else {
                if (state.currentPosition) {
                    profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                    profit = state.positionAmount * (profitPercent / 100);
                    state.portfolio.profit += profit;
                    
                    success = profit > 0;
                    if (success) state.aiStats.successfulTrades++;
                    
                    state.currentPosition = null;
                    document.getElementById('positionStatus').innerHTML = '‚ö™ Aucune';
                }
            }
            
            // Update AI stats
            state.aiStats.totalTrades++;
            state.aiStats.accuracy = state.aiStats.totalTrades > 0 
                ? (state.aiStats.successfulTrades / state.aiStats.totalTrades * 100).toFixed(0) 
                : 0;
            
            const trade = {
                id: Date.now(),
                time: new Date().toLocaleTimeString('fr-FR'),
                date: new Date().toLocaleDateString('fr-FR'),
                type: tradeType,
                pair: state.selectedCrypto,
                amount: amount.toFixed(2),
                entryPrice: state.currentPrice.toFixed(6),
                profit: profit.toFixed(2),
                profitPercent: profitPercent.toFixed(2),
                confidence: (decision.confidence * 100).toFixed(0),
                reason: decision.reason,
                mode: 'simulation',
                success: success,
                txHash: null
            };
            
            state.trades.unshift(trade);
            state.trades = state.trades.slice(0, 50);
            
            playTradeSound();
            saveState();
            renderTrades();
            updateStats();
        }

        // REAL TRADING MODE
        async function executeRealTrade(tradeType, amount, decision) {
            try {
                if (!state.provider || !state.account) {
                    alert('‚ùå Wallet non connect√©');
                    return;
                }

                // V√©rifier si transaction en cours
                if (state.realTrading.pendingTx) {
                    console.log('‚è≥ Transaction d√©j√† en cours...');
                    return;
                }

                const signer = state.wallet || state.provider.getSigner();
                const tokenAddress = TOKEN_ADDRESSES[state.selectedCrypto];
                
                let txHash = null;
                let success = false;
                let profit = 0;
                let profitPercent = 0;

                if (tradeType === 'BUY') {
                    // ACHAT R√âEL
                    console.log('üíé Ex√©cution ACHAT R√âEL...');
                    txHash = await executeBuyOnPancakeSwap(signer, tokenAddress, amount);
                    
                    if (txHash) {
                        state.currentPosition = 'BUY';
                        state.lastBuyPrice = state.currentPrice;
                        state.positionAmount = amount;
                        document.getElementById('positionStatus').innerHTML = 'üü¢ Long (R√âEL)';
                        success = true;
                    }
                } else {
                    // VENTE R√âELLE
                    console.log('üíé Ex√©cution VENTE R√âELLE...');
                    txHash = await executeSellOnPancakeSwap(signer, tokenAddress, state.positionAmount);
                    
                    if (txHash && state.currentPosition) {
                        profitPercent = ((state.currentPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                        profit = state.positionAmount * (profitPercent / 100);
                        state.portfolio.profit += profit;
                        
                        success = profit > 0;
                        if (success) state.aiStats.successfulTrades++;
                        
                        state.currentPosition = null;
                        document.getElementById('positionStatus').innerHTML = '‚ö™ Aucune';
                    }
                }

                // Update stats
                state.aiStats.totalTrades++;
                state.aiStats.accuracy = state.aiStats.totalTrades > 0 
                    ? (state.aiStats.successfulTrades / state.aiStats.totalTrades * 100).toFixed(0) 
                    : 0;

                const trade = {
                    id: Date.now(),
                    time: new Date().toLocaleTimeString('fr-FR'),
                    date: new Date().toLocaleDateString('fr-FR'),
                    type: tradeType,
                    pair: state.selectedCrypto,
                    amount: amount.toFixed(2),
                    entryPrice: state.currentPrice.toFixed(6),
                    profit: profit.toFixed(2),
                    profitPercent: profitPercent.toFixed(2),
                    confidence: (decision.confidence * 100).toFixed(0),
                    reason: decision.reason,
                    mode: 'real',
                    success: success,
                    txHash: txHash
                };

                state.trades.unshift(trade);
                state.trades = state.trades.slice(0, 50);

                playTradeSound();
                saveState();
                renderTrades();
                updateStats();

                if (txHash) {
                    alert(`‚úÖ Transaction r√©ussie!\n\nTx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}\n\nVoir sur BSCScan: https://bscscan.com/tx/${txHash}`);
                }

            } catch (error) {
                console.error('‚ùå Erreur trade r√©el:', error);
                alert(`‚ùå Erreur lors du trade:\n\n${error.message}\n\nLe bot continue en mode simulation.`);
            }
        }

        // ACHETER sur PancakeSwap
        async function executeBuyOnPancakeSwap(signer, tokenAddress, usdtAmount) {
            try {
                console.log('üîÑ Pr√©paration achat PancakeSwap...');
                
                const routerContract = new ethers.Contract(PANCAKE_ROUTER, ROUTER_ABI, signer);
                const usdtContract = new ethers.Contract(USDT_CONTRACT, ERC20_ABI, signer);
                
                // Convertir montant en Wei (USDT a 18 decimals sur BSC)
                const amountIn = ethers.utils.parseUnits(usdtAmount.toString(), 18);
                
                // V√©rifier allowance
                const allowance = await usdtContract.allowance(state.account, PANCAKE_ROUTER);
                console.log('üìä Allowance actuelle:', ethers.utils.formatUnits(allowance, 18));
                
                if (allowance.lt(amountIn)) {
                    console.log('‚úçÔ∏è Approval n√©cessaire...');
                    const approveTx = await usdtContract.approve(
                        PANCAKE_ROUTER, 
                        ethers.constants.MaxUint256
                    );
                    console.log('‚è≥ Attente confirmation approval:', approveTx.hash);
                    await approveTx.wait();
                    console.log('‚úÖ Approval confirm√©e');
                }
                
                // Path: USDT -> Token
                const path = [USDT_CONTRACT, tokenAddress];
                
                // Calculer montant minimum avec slippage 1%
                const amountsOut = await routerContract.getAmountsOut(amountIn, path);
                const amountOutMin = amountsOut[1].mul(99).div(100); // 1% slippage
                
                // Deadline: 20 minutes
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                
                console.log('üí± Swap USDT -> Token...');
                console.log('   Amount In:', ethers.utils.formatUnits(amountIn, 18), 'USDT');
                console.log('   Amount Out Min:', ethers.utils.formatUnits(amountOutMin, 18), 'Token');
                
                state.realTrading.pendingTx = true;
                
                const swapTx = await routerContract.swapExactTokensForTokens(
                    amountIn,
                    amountOutMin,
                    path,
                    state.account,
                    deadline,
                    { gasLimit: 300000 }
                );
                
                console.log('‚è≥ Transaction envoy√©e:', swapTx.hash);
                const receipt = await swapTx.wait();
                
                state.realTrading.pendingTx = false;
                
                console.log('‚úÖ ACHAT confirm√©!');
                console.log('üìù Gas utilis√©:', receipt.gasUsed.toString());
                
                return swapTx.hash;
                
            } catch (error) {
                state.realTrading.pendingTx = false;
                console.error('‚ùå Erreur achat:', error);
                throw error;
            }
        }

        // REAL BINANCE SPOT TRADING
        async function executeRealBinanceTrade(tradeType, amount, decision) {
            try {
                if (!state.binance.connected) {
                    alert('‚ùå Binance API non connect√©e');
                    return;
                }

                if (state.realTrading.pendingTx) {
                    console.log('‚è≥ Transaction d√©j√† en cours...');
                    return;
                }

                let orderId = null;
                let success = false;
                let profit = 0;
                let profitPercent = 0;
                let executedQty = 0;
                let executedPrice = 0;

                const symbol = state.selectedCrypto; // Ex: BTCUSDT
                const timestamp = Date.now();

                if (tradeType === 'BUY') {
                    // ACHAT R√âEL sur Binance
                    console.log('üü° Ex√©cution ACHAT R√âEL Binance...');
                    
                    // Cr√©er ordre Market BUY
                    const params = `symbol=${symbol}&side=BUY&type=MARKET&quoteOrderQty=${amount}&timestamp=${timestamp}`;
                    const signature = await createBinanceSignature(state.binance.secretKey, params);
                    
                    state.realTrading.pendingTx = true;
                    
                    const response = await fetch(`https://api.binance.com/api/v3/order?${params}&signature=${signature}`, {
                        method: 'POST',
                        headers: {
                            'X-MBX-APIKEY': state.binance.apiKey
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        orderId = data.orderId;
                        executedQty = parseFloat(data.executedQty);
                        
                        // Calculer prix moyen d'ex√©cution
                        const fills = data.fills || [];
                        let totalCost = 0;
                        let totalQty = 0;
                        
                        fills.forEach(fill => {
                            totalCost += parseFloat(fill.price) * parseFloat(fill.qty);
                            totalQty += parseFloat(fill.qty);
                        });
                        
                        executedPrice = totalQty > 0 ? totalCost / totalQty : state.currentPrice;
                        
                        state.currentPosition = 'BUY';
                        state.lastBuyPrice = executedPrice;
                        state.positionAmount = amount;
                        document.getElementById('positionStatus').innerHTML = 'üü¢ Long (Binance)';
                        success = true;
                        
                        console.log('‚úÖ ACHAT Binance confirm√©!');
                        console.log('Order ID:', orderId);
                        console.log('Quantit√©:', executedQty);
                        console.log('Prix moyen:', executedPrice);
                    } else {
                        const error = await response.json();
                        throw new Error(error.msg || 'Erreur ordre');
                    }

                } else {
                    // VENTE R√âELLE sur Binance
                    console.log('üü° Ex√©cution VENTE R√âELLE Binance...');
                    
                    if (!state.currentPosition) {
                        throw new Error('Aucune position ouverte');
                    }
                    
                    // Obtenir le solde du token pour vendre tout
                    const accountParams = `timestamp=${timestamp}`;
                    const accountSignature = await createBinanceSignature(state.binance.secretKey, accountParams);
                    
                    const accountResponse = await fetch(`https://api.binance.com/api/v3/account?${accountParams}&signature=${accountSignature}`, {
                        headers: {
                            'X-MBX-APIKEY': state.binance.apiKey
                        }
                    });
                    
                    if (!accountResponse.ok) {
                        throw new Error('Impossible de r√©cup√©rer le solde');
                    }
                    
                    const accountData = await accountResponse.json();
                    const baseAsset = symbol.replace('USDT', ''); // Ex: BTC from BTCUSDT
                    const assetBalance = accountData.balances.find(b => b.asset === baseAsset);
                    
                    if (!assetBalance || parseFloat(assetBalance.free) === 0) {
                        throw new Error('Aucun token √† vendre');
                    }
                    
                    const qtyToSell = parseFloat(assetBalance.free);
                    
                    // Cr√©er ordre Market SELL
                    const sellParams = `symbol=${symbol}&side=SELL&type=MARKET&quantity=${qtyToSell}&timestamp=${timestamp}`;
                    const sellSignature = await createBinanceSignature(state.binance.secretKey, sellParams);
                    
                    state.realTrading.pendingTx = true;
                    
                    const sellResponse = await fetch(`https://api.binance.com/api/v3/order?${sellParams}&signature=${sellSignature}`, {
                        method: 'POST',
                        headers: {
                            'X-MBX-APIKEY': state.binance.apiKey
                        }
                    });

                    if (sellResponse.ok) {
                        const data = await sellResponse.json();
                        orderId = data.orderId;
                        
                        // Calculer prix moyen d'ex√©cution
                        const fills = data.fills || [];
                        let totalValue = 0;
                        let totalQty = 0;
                        
                        fills.forEach(fill => {
                            totalValue += parseFloat(fill.price) * parseFloat(fill.qty);
                            totalQty += parseFloat(fill.qty);
                        });
                        
                        executedPrice = totalQty > 0 ? totalValue / totalQty : state.currentPrice;
                        
                        // Calculer profit
                        profitPercent = ((executedPrice - state.lastBuyPrice) / state.lastBuyPrice) * 100;
                        profit = state.positionAmount * (profitPercent / 100);
                        state.portfolio.profit += profit;
                        
                        success = profit > 0;
                        if (success) state.aiStats.successfulTrades++;
                        
                        state.currentPosition = null;
                        document.getElementById('positionStatus').innerHTML = '‚ö™ Aucune';
                        
                        console.log('‚úÖ VENTE Binance confirm√©e!');
                        console.log('Order ID:', orderId);
                        console.log('Prix moyen:', executedPrice);
                        console.log('Profit:', profit.toFixed(2), 'USDT');
                    } else {
                        const error = await sellResponse.json();
                        throw new Error(error.msg || 'Erreur ordre');
                    }
                }

                state.realTrading.pendingTx = false;

                // Update stats
                state.aiStats.totalTrades++;
                state.aiStats.accuracy = state.aiStats.totalTrades > 0 
                    ? (state.aiStats.successfulTrades / state.aiStats.totalTrades * 100).toFixed(0) 
                    : 0;

                const trade = {
                    id: Date.now(),
                    time: new Date().toLocaleTimeString('fr-FR'),
                    date: new Date().toLocaleDateString('fr-FR'),
                    type: tradeType,
                    pair: state.selectedCrypto,
                    amount: amount.toFixed(2),
                    entryPrice: executedPrice.toFixed(6),
                    profit: profit.toFixed(2),
                    profitPercent: profitPercent.toFixed(2),
                    confidence: (decision.confidence * 100).toFixed(0),
                    reason: decision.reason,
                    mode: 'real-binance',
                    success: success,
                    txHash: null,
                    orderId: orderId
                };

                state.trades.unshift(trade);
                state.trades = state.trades.slice(0, 50);

                playTradeSound();
                saveState();
                renderTrades();
                updateStats();

                if (orderId) {
                    alert(`‚úÖ Ordre Binance ex√©cut√©!\n\nOrder ID: ${orderId}\nPrix: ${executedPrice.toFixed(6)}\n${profit > 0 ? 'Profit: +' + profit.toFixed(2) + ' USDT' : ''}`);
                }

            } catch (error) {
                state.realTrading.pendingTx = false;
                console.error('‚ùå Erreur trade Binance:', error);
                alert(`‚ùå Erreur lors du trade Binance:\n\n${error.message}\n\nLe bot continue.`);
            }
        }

        // VENDRE sur PancakeSwap
        async function executeSellOnPancakeSwap(signer, tokenAddress, usdtAmount) {
            try {
                console.log('üîÑ Pr√©paration vente PancakeSwap...');
                
                const routerContract = new ethers.Contract(PANCAKE_ROUTER, ROUTER_ABI, signer);
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
                
                // R√©cup√©rer balance token
                const tokenBalance = await tokenContract.balanceOf(state.account);
                console.log('üí∞ Balance Token:', ethers.utils.formatUnits(tokenBalance, 18));
                
                if (tokenBalance.eq(0)) {
                    throw new Error('Aucun token √† vendre');
                }
                
                // Utiliser tout le balance
                const amountIn = tokenBalance;
                
                // V√©rifier allowance
                const allowance = await tokenContract.allowance(state.account, PANCAKE_ROUTER);
                
                if (allowance.lt(amountIn)) {
                    console.log('‚úçÔ∏è Approval Token n√©cessaire...');
                    const approveTx = await tokenContract.approve(
                        PANCAKE_ROUTER,
                        ethers.constants.MaxUint256
                    );
                    console.log('‚è≥ Attente confirmation approval:', approveTx.hash);
                    await approveTx.wait();
                    console.log('‚úÖ Approval confirm√©e');
                }
                
                // Path: Token -> USDT
                const path = [tokenAddress, USDT_CONTRACT];
                
                // Calculer montant minimum avec slippage 1%
                const amountsOut = await routerContract.getAmountsOut(amountIn, path);
                const amountOutMin = amountsOut[1].mul(99).div(100);
                
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                
                console.log('üí± Swap Token -> USDT...');
                console.log('   Amount In:', ethers.utils.formatUnits(amountIn, 18), 'Token');
                console.log('   Amount Out Min:', ethers.utils.formatUnits(amountOutMin, 18), 'USDT');
                
                state.realTrading.pendingTx = true;
                
                const swapTx = await routerContract.swapExactTokensForTokens(
                    amountIn,
                    amountOutMin,
                    path,
                    state.account,
                    deadline,
                    { gasLimit: 300000 }
                );
                
                console.log('‚è≥ Transaction envoy√©e:', swapTx.hash);
                const receipt = await swapTx.wait();
                
                state.realTrading.pendingTx = false;
                
                console.log('‚úÖ VENTE confirm√©e!');
                console.log('üìù Gas utilis√©:', receipt.gasUsed.toString());
                
                return swapTx.hash;
                
            } catch (error) {
                state.realTrading.pendingTx = false;
                console.error('‚ùå Erreur vente:', error);
                throw error;
            }
        }

        function renderTrades() {
            if (state.trades.length === 0) return;
            
            document.getElementById('tradesContainer').innerHTML = state.trades.map(t => `
                <div class="flex items-center justify-between p-4 bg-slate-700/50 rounded-lg mb-2 border-l-4 ${t.type === 'BUY' ? 'border-purple-400' : t.success ? 'border-green-400' : 'border-red-400'}">
                    <div class="flex items-center gap-4">
                        <span class="${t.type === 'BUY' ? 'text-purple-400' : t.success ? 'text-green-400' : 'text-red-400'} text-3xl">
                            ${t.type === 'BUY' ? 'ü§ñ' : t.success ? '‚úÖ' : '‚ùå'}
                        </span>
                        <div>
                            <div class="flex items-center gap-2 mb-1">
                                <p class="font-bold text-lg">${t.type === 'BUY' ? 'ACHAT IA' : 'VENTE IA'}</p>
                                <span class="text-xs bg-purple-400/20 text-purple-400 px-2 py-0.5 rounded font-bold">${t.pair}</span>
                                ${t.mode === 'real' ? '<span class="text-xs bg-orange-400/20 text-orange-400 px-2 py-0.5 rounded">üíé R√âEL</span>' : '<span class="text-xs bg-blue-400/20 text-blue-400 px-2 py-0.5 rounded">üéÆ SIM</span>'}
                            </div>
                            <p class="text-xs text-gray-400 mb-1">${t.date} ${t.time} ‚Ä¢ ${t.amount} USDT ‚Ä¢ Confiance ${t.confidence}%</p>
                            <p class="text-xs text-purple-300 italic">"${t.reason}"</p>
                            ${t.txHash ? `<a href="https://bscscan.com/tx/${t.txHash}" target="_blank" class="text-xs text-blue-400 hover:text-blue-300 underline">üìù BSCScan</a>` : ''}
                            ${t.orderId ? `<p class="text-xs text-yellow-400">üü° Binance Order: ${t.orderId}</p>` : ''}
                        </div>
                    </div>
                    <div class="text-right">
                        <p class="text-sm font-mono">${t.entryPrice}</p>
                        ${t.type === 'SELL' ? `
                            <p class="text-lg font-bold ${parseFloat(t.profit) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${parseFloat(t.profit) >= 0 ? '+' : ''}${t.profit} USDT
                            </p>
                            <p class="text-sm font-semibold ${parseFloat(t.profitPercent) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${parseFloat(t.profitPercent) >= 0 ? '+' : ''}${t.profitPercent}%
                            </p>
                        ` : '<p class="text-sm text-purple-400">Position ouverte</p>'}
                    </div>
                </div>
            `).join('');
        }

        function updateStats() {
            document.getElementById('profitDisplay').textContent = state.portfolio.profit.toFixed(2);
            document.getElementById('aiAccuracy').textContent = state.aiStats.accuracy;
            document.getElementById('aiTrades').textContent = state.aiStats.totalTrades;
            document.getElementById('successRate').textContent = state.aiStats.accuracy + '%';
        }

        // Wake Lock API - Emp√™che la mise en veille
        async function toggleWakeLock() {
            const toggle = document.getElementById('wakeLockToggle');
            
            if (toggle.checked) {
                await requestWakeLock();
            } else {
                releaseWakeLock();
            }
        }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('üîã Wake Lock activ√©');
                    document.getElementById('wakeLockStatus').innerHTML = 'Status: <span class="text-green-400">‚úÖ Actif</span>';
                    
                    wakeLock.addEventListener('release', () => {
                        console.log('üîã Wake Lock d√©sactiv√©');
                        document.getElementById('wakeLockStatus').innerHTML = 'Status: <span class="text-red-400">D√©sactiv√©</span>';
                    });
                } else {
                    alert('‚ö†Ô∏è Wake Lock non support√© par ce navigateur.\nLe bot fonctionnera quand m√™me en arri√®re-plan.');
                    document.getElementById('wakeLockToggle').checked = false;
                }
            } catch (err) {
                console.error('Erreur Wake Lock:', err);
                alert('‚ùå Impossible d\'activer le mode veille: ' + err.message);
                document.getElementById('wakeLockToggle').checked = false;
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
                console.log('üîã Wake Lock lib√©r√©');
                document.getElementById('wakeLockStatus').innerHTML = 'Status: <span class="text-red-400">D√©sactiv√©</span>';
            }
        }

        // Listener pour r√©activer le Wake Lock si la page redevient visible
        function initVisibilityListener() {
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible' && document.getElementById('wakeLockToggle').checked) {
                    console.log('üëÅÔ∏è Page visible - R√©activation Wake Lock');
                    await requestWakeLock();
                }
            });
        }

        // Keep Alive - Emp√™che la suspension du JavaScript
        function initKeepAlive() {
            // Ping toutes les 30 secondes pour garder le script actif
            keepAliveInterval = setInterval(() => {
                if (state.botRunning) {
                    console.log('üíì Keep Alive - Bot actif');
                    
                    // Si le WebSocket est ferm√©, le reconnecter
                    if (!ws || ws.readyState === WebSocket.CLOSED) {
                        console.log('üîÑ Reconnexion WebSocket...');
                        connectWebSocket();
                    }
                }
            }, 30000);
        }

        // Notification audio quand un trade est ex√©cut√©
        function playTradeSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log('Son d√©sactiv√©');
            }
        }

        // Sauvegarder l'√©tat du bot dans localStorage
        function saveState() {
            if (state.isConnected && state.capitalSet) {
                const stateToSave = {
                    tradingCapital: state.tradingCapital,
                    portfolio: state.portfolio,
                    aiStats: state.aiStats,
                    trades: state.trades.slice(0, 20),
                    selectedCrypto: state.selectedCrypto,
                    tradingMode: state.tradingMode,
                    lastSaved: new Date().toISOString()
                };
                localStorage.setItem('botTradingState', JSON.stringify(stateToSave));
                console.log('üíæ √âtat sauvegard√©');
            }
        }

        // Restaurer l'√©tat du bot
        function restoreState() {
            try {
                const saved = localStorage.getItem('botTradingState');
                if (saved) {
                    const restored = JSON.parse(saved);
                    
                    // V√©rifier que la sauvegarde n'est pas trop ancienne (24h max)
                    const lastSaved = new Date(restored.lastSaved);
                    const hoursSince = (Date.now() - lastSaved.getTime()) / (1000 * 60 * 60);
                    
                    if (hoursSince < 24) {
                        console.log('‚ôªÔ∏è Restauration de l\'√©tat...');
                        return restored;
                    }
                }
            } catch (e) {
                console.error('Erreur restauration:', e);
            }
            return null;
        }

        // Sauvegarder automatiquement toutes les 5 minutes
        setInterval(saveState, 5 * 60 * 1000);

        // Sauvegarder avant de fermer la page
        window.addEventListener('beforeunload', (e) => {
            if (state.botRunning) {
                saveState();
                e.preventDefault();
                e.returnValue = 'Le bot est en cours d\'ex√©cution. √ätes-vous s√ªr de vouloir quitter?';
            }
        });
    </script>
</body>
</html>
