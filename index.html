<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Trading Avanc√© - Binance & MetaMask</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-card h3 {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 10px;
        }

        .status-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .green { background: #10b981; }
        .yellow { background: #f59e0b; }
        .red { background: #ef4444; }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .panel h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1em;
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: #10b981;
            color: white;
        }

        .btn-primary:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #3b82f6;
            color: white;
        }

        .btn-secondary:hover {
            background: #2563eb;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .indicator-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .indicator-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }

        .indicator-card:hover {
            border-color: rgba(255, 255, 255, 0.4);
        }

        .indicator-card.active {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
        }

        .indicator-card h4 {
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .indicator-settings {
            margin-top: 10px;
        }

        .indicator-settings input {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .price-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .price-display .price {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }

        .price-display .change {
            font-size: 1.2em;
        }

        .change.positive { color: #10b981; }
        .change.negative { color: #ef4444; }

        .log-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #3b82f6;
            padding-left: 10px;
        }

        .log-entry.success { border-left-color: #10b981; }
        .log-entry.error { border-left-color: #ef4444; }
        .log-entry.warning { border-left-color: #f59e0b; }

        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }

        .trading-pair-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .trading-pair-selector button {
            padding: 8px 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .trading-pair-selector button:hover,
        .trading-pair-selector button.active {
            background: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
        }

        .alert-box {
            background: rgba(251, 191, 36, 0.2);
            border: 2px solid #f59e0b;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .indicator-values {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .indicator-value-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .indicator-value-card .label {
            font-size: 0.8em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .indicator-value-card .value {
            font-size: 1.2em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Bot Trading Avanc√©</h1>
            <p>Plateforme de Trading Automatis√© avec Indicateurs Techniques</p>
        </div>

        <!-- Status Grid -->
        <div class="status-grid">
            <div class="status-card">
                <h3>Wallet</h3>
                <div class="status-value">
                    <span class="status-indicator" id="walletStatus"></span>
                    <span id="walletText">D√©connect√©</span>
                </div>
            </div>
            <div class="status-card">
                <h3>Mode Trading</h3>
                <div class="status-value">
                    <span class="status-indicator" id="modeStatus"></span>
                    <span id="modeText">Manuel</span>
                </div>
            </div>
            <div class="status-card">
                <h3>Position</h3>
                <div class="status-value">
                    <span class="status-indicator" id="positionStatus"></span>
                    <span id="positionText">Aucune</span>
                </div>
            </div>
            <div class="status-card">
                <h3>Binance API</h3>
                <div class="status-value">
                    <span class="status-indicator" id="binanceStatus"></span>
                    <span id="binanceText">D√©connect√©</span>
                </div>
            </div>
            <div class="status-card">
                <h3>Ethers.js</h3>
                <div class="status-value">
                    <span class="status-indicator green"></span>
                    <span>v5.7.2</span>
                </div>
            </div>
            <div class="status-card">
                <h3>Wake Lock</h3>
                <div class="status-value">
                    <span class="status-indicator" id="wakeLockStatus"></span>
                    <span id="wakeLockText">Rel√¢ch√©</span>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Panel -->
            <div>
                <!-- Connection Panel -->
                <div class="panel">
                    <h2>üîê Connexion</h2>
                    
                    <div class="form-group">
                        <label>MetaMask (Cl√© Priv√©e)</label>
                        <input type="password" id="privateKey" placeholder="Entrez votre cl√© priv√©e">
                        <small style="opacity: 0.7; display: block; margin-top: 5px;">‚ö†Ô∏è Ne partagez jamais votre cl√© priv√©e</small>
                    </div>

                    <button class="btn btn-primary" onclick="connectWallet()">Connecter Wallet</button>

                    <div class="form-group" style="margin-top: 20px;">
                        <label>Binance API Key</label>
                        <input type="text" id="binanceApiKey" placeholder="Votre API Key Binance">
                    </div>

                    <div class="form-group">
                        <label>Binance Secret Key</label>
                        <input type="password" id="binanceSecretKey" placeholder="Votre Secret Key Binance">
                    </div>

                    <button class="btn btn-secondary" onclick="connectBinance()">Connecter Binance</button>
                </div>

                <!-- Trading Pair Selection -->
                <div class="panel" style="margin-top: 20px;">
                    <h2>üìä Paire de Trading</h2>
                    <div class="trading-pair-selector">
                        <button onclick="selectPair('BTCUSDT')" class="active">BTC/USDT</button>
                        <button onclick="selectPair('ETHUSDT')">ETH/USDT</button>
                        <button onclick="selectPair('BNBUSDT')">BNB/USDT</button>
                        <button onclick="selectPair('ADAUSDT')">ADA/USDT</button>
                        <button onclick="selectPair('SOLUSDT')">SOL/USDT</button>
                        <button onclick="selectPair('XRPUSDT')">XRP/USDT</button>
                    </div>

                    <div class="price-display">
                        <div style="opacity: 0.8;">Prix Actuel</div>
                        <div class="price" id="currentPrice">$0.00</div>
                        <div class="change" id="priceChange">+0.00%</div>
                    </div>
                </div>

                <!-- Trading Controls -->
                <div class="panel" style="margin-top: 20px;">
                    <h2>‚öôÔ∏è Contr√¥les de Trading</h2>
                    
                    <div class="form-group">
                        <label>Montant d'Investissement (USDT)</label>
                        <input type="number" id="investAmount" value="100" min="10">
                    </div>

                    <div class="form-group">
                        <label>Mode de Trading</label>
                        <select id="tradingMode" onchange="updateTradingMode()">
                            <option value="manual">Manuel</option>
                            <option value="auto">Automatique 24/7</option>
                        </select>
                    </div>

                    <button class="btn btn-primary" onclick="startBot()" id="startBtn">‚ñ∂Ô∏è D√©marrer le Bot</button>
                    <button class="btn btn-danger" onclick="stopBot()" id="stopBtn" disabled>‚èπÔ∏è Arr√™ter le Bot</button>
                </div>
            </div>

            <!-- Right Panel -->
            <div>
                <!-- Indicators Selection -->
                <div class="panel">
                    <h2>üìà S√©lection des Indicateurs</h2>
                    <p style="opacity: 0.8; margin-bottom: 15px;">Cliquez sur les indicateurs que vous souhaitez utiliser et configurez leurs param√®tres</p>
                    
                    <div class="indicator-selector" id="indicatorSelector">
                        <!-- Indicators will be populated here -->
                    </div>
                </div>

                <!-- Indicator Values Display -->
                <div class="panel" style="margin-top: 20px;">
                    <h2>üìä Valeurs des Indicateurs en Temps R√©el</h2>
                    <div class="indicator-values" id="indicatorValues">
                        <!-- Real-time indicator values will be displayed here -->
                    </div>
                </div>

                <!-- Chart -->
                <div class="panel" style="margin-top: 20px;">
                    <h2>üìâ Graphique de Prix</h2>
                    <div class="chart-container">
                        <canvas id="priceChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="panel">
            <h2>üìù Journal d'Activit√©</h2>
            <div class="log-panel" id="logPanel">
                <div class="log-entry">Syst√®me initialis√©. En attente de connexion...</div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let wallet = null;
        let provider = null;
        let currentPair = 'BTCUSDT';
        let botActive = false;
        let priceChart = null;
        let priceData = [];
        let ohlcvData = []; // Pour stocker Open, High, Low, Close, Volume
        let indicatorData = {};
        let binanceWs = null;
        let binanceKlineWs = null;
        let wakeLock = null;
        let selectedIndicators = {};
        let lastPrice = 0;

        // Available Indicators
        const availableIndicators = {
            rsi: {
                name: 'RSI',
                fullName: 'Relative Strength Index',
                params: { period: 14, overbought: 70, oversold: 30 }
            },
            macd: {
                name: 'MACD',
                fullName: 'Moving Average Convergence Divergence',
                params: { fast: 12, slow: 26, signal: 9 }
            },
            ema: {
                name: 'EMA',
                fullName: 'Exponential Moving Average',
                params: { period: 20 }
            },
            sma: {
                name: 'SMA',
                fullName: 'Simple Moving Average',
                params: { period: 50 }
            },
            bollinger: {
                name: 'Bollinger',
                fullName: 'Bollinger Bands',
                params: { period: 20, stdDev: 2 }
            },
            stochastic: {
                name: 'Stochastic',
                fullName: 'Stochastic Oscillator',
                params: { k: 14, d: 3, overbought: 80, oversold: 20 }
            },
            atr: {
                name: 'ATR',
                fullName: 'Average True Range',
                params: { period: 14 }
            },
            adx: {
                name: 'ADX',
                fullName: 'Average Directional Index',
                params: { period: 14 }
            },
            cci: {
                name: 'CCI',
                fullName: 'Commodity Channel Index',
                params: { period: 20 }
            },
            obv: {
                name: 'OBV',
                fullName: 'On Balance Volume',
                params: {}
            },
            vwap: {
                name: 'VWAP',
                fullName: 'Volume Weighted Average Price',
                params: {}
            },
            fibonacci: {
                name: 'Fibonacci',
                fullName: 'Fibonacci Retracement',
                params: { lookback: 100 }
            },
            ichimoku: {
                name: 'Ichimoku',
                fullName: 'Ichimoku Cloud',
                params: { tenkan: 9, kijun: 26, senkou: 52 }
            },
            parabolicSar: {
                name: 'Parabolic SAR',
                fullName: 'Parabolic Stop and Reverse',
                params: { acceleration: 0.02, maximum: 0.2 }
            },
            williamsR: {
                name: 'Williams %R',
                fullName: 'Williams Percent Range',
                params: { period: 14 }
            }
        };

        // Initialize
        window.onload = function() {
            initializeIndicatorSelector();
            initializeChart();
            addLog('Syst√®me initialis√© avec succ√®s', 'success');
            requestWakeLock();
        };

        // Initialize Indicator Selector
        function initializeIndicatorSelector() {
            const selector = document.getElementById('indicatorSelector');
            selector.innerHTML = '';

            for (const [key, indicator] of Object.entries(availableIndicators)) {
                const card = document.createElement('div');
                card.className = 'indicator-card';
                card.id = `indicator-${key}`;
                
                let paramsHtml = '';
                for (const [paramKey, paramValue] of Object.entries(indicator.params)) {
                    paramsHtml += `
                        <div style="margin-top: 8px;">
                            <small>${paramKey}:</small>
                            <input type="number" 
                                   id="${key}-${paramKey}" 
                                   value="${paramValue}" 
                                   step="0.01"
                                   style="width: 100%; padding: 5px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white;">
                        </div>
                    `;
                }

                card.innerHTML = `
                    <h4>${indicator.name}</h4>
                    <small style="opacity: 0.7;">${indicator.fullName}</small>
                    <div class="indicator-settings" id="settings-${key}" style="display: none;">
                        ${paramsHtml}
                    </div>
                `;

                card.onclick = function() {
                    toggleIndicator(key);
                };

                selector.appendChild(card);
            }
        }

        // Toggle Indicator Selection
        function toggleIndicator(key) {
            const card = document.getElementById(`indicator-${key}`);
            const settings = document.getElementById(`settings-${key}`);
            
            if (selectedIndicators[key]) {
                delete selectedIndicators[key];
                card.classList.remove('active');
                settings.style.display = 'none';
                addLog(`Indicateur ${availableIndicators[key].name} d√©sactiv√©`, 'warning');
            } else {
                selectedIndicators[key] = { ...availableIndicators[key] };
                card.classList.add('active');
                settings.style.display = 'block';
                addLog(`Indicateur ${availableIndicators[key].name} activ√©`, 'success');
            }
        }

        // Connect Wallet
        async function connectWallet() {
            const privateKey = document.getElementById('privateKey').value;
            
            if (!privateKey) {
                addLog('Veuillez entrer votre cl√© priv√©e', 'error');
                return;
            }

            try {
                provider = new ethers.providers.JsonRpcProvider('https://bsc-dataseed1.binance.org:443');
                wallet = new ethers.Wallet(privateKey, provider);
                
                updateStatus('walletStatus', 'green');
                document.getElementById('walletText').textContent = 'Connect√©';
                
                const balance = await provider.getBalance(wallet.address);
                const balanceInBnb = ethers.utils.formatEther(balance);
                
                addLog(`Wallet connect√©: ${wallet.address.substring(0, 10)}...`, 'success');
                addLog(`Balance: ${parseFloat(balanceInBnb).toFixed(4)} BNB`, 'success');
                
            } catch (error) {
                addLog(`Erreur de connexion wallet: ${error.message}`, 'error');
                updateStatus('walletStatus', 'red');
            }
        }

        // Connect Binance
        function connectBinance() {
            const apiKey = document.getElementById('binanceApiKey').value;
            const secretKey = document.getElementById('binanceSecretKey').value;

            if (!apiKey || !secretKey) {
                addLog('Veuillez entrer vos cl√©s API Binance', 'error');
                return;
            }

            // Store keys (in production, use secure storage)
            sessionStorage.setItem('binanceApiKey', apiKey);
            sessionStorage.setItem('binanceSecretKey', secretKey);

            updateStatus('binanceStatus', 'green');
            document.getElementById('binanceText').textContent = 'Connect√©';
            addLog('Binance API connect√©e avec succ√®s', 'success');

            // Start price feed
            connectBinanceWebSocket();
        }

        // Connect Binance WebSocket
        function connectBinanceWebSocket() {
            if (binanceWs) {
                binanceWs.close();
            }
            if (binanceKlineWs) {
                binanceKlineWs.close();
            }

            const symbol = currentPair.toLowerCase();
            
            // WebSocket pour les prix en temps r√©el (trades)
            binanceWs = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@trade`);

            binanceWs.onopen = function() {
                addLog('WebSocket Binance (Trades) connect√©', 'success');
            };

            binanceWs.onmessage = function(event) {
                const data = JSON.parse(event.data);
                updatePrice(parseFloat(data.p));
            };

            binanceWs.onerror = function(error) {
                addLog('Erreur WebSocket Trades: ' + error.message, 'error');
            };

            binanceWs.onclose = function() {
                addLog('WebSocket Trades d√©connect√©', 'warning');
                setTimeout(connectBinanceWebSocket, 5000);
            };

            // WebSocket pour les chandeliers OHLCV (klines) - 1 minute
            binanceKlineWs = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@kline_1m`);

            binanceKlineWs.onopen = function() {
                addLog('WebSocket Binance (Klines) connect√©', 'success');
                // Charger l'historique initial
                loadHistoricalData();
            };

            binanceKlineWs.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.k) {
                    const kline = data.k;
                    updateOHLCV({
                        time: new Date(kline.t),
                        open: parseFloat(kline.o),
                        high: parseFloat(kline.h),
                        low: parseFloat(kline.l),
                        close: parseFloat(kline.c),
                        volume: parseFloat(kline.v),
                        isClosed: kline.x
                    });
                }
            };

            binanceKlineWs.onerror = function(error) {
                addLog('Erreur WebSocket Klines: ' + error.message, 'error');
            };

            binanceKlineWs.onclose = function() {
                addLog('WebSocket Klines d√©connect√©', 'warning');
            };
        }

        // Charger les donn√©es historiques depuis l'API Binance
        async function loadHistoricalData() {
            try {
                const symbol = currentPair;
                const interval = '1m';
                const limit = 200; // Charger 200 chandeliers pour avoir assez de donn√©es
                
                const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                const response = await fetch(url);
                const data = await response.json();
                
                ohlcvData = data.map(candle => ({
                    time: new Date(candle[0]),
                    open: parseFloat(candle[1]),
                    high: parseFloat(candle[2]),
                    low: parseFloat(candle[3]),
                    close: parseFloat(candle[4]),
                    volume: parseFloat(candle[5]),
                    isClosed: true
                }));
                
                // Initialiser priceData avec les donn√©es historiques
                priceData = ohlcvData.map(d => ({
                    time: d.time,
                    price: d.close
                }));
                
                lastPrice = ohlcvData[ohlcvData.length - 1].close;
                updateChart();
                addLog(`${limit} chandeliers historiques charg√©s`, 'success');
                
                // Calculer les indicateurs avec les donn√©es historiques
                if (botActive && Object.keys(selectedIndicators).length > 0) {
                    calculateIndicators();
                }
            } catch (error) {
                addLog('Erreur chargement historique: ' + error.message, 'error');
            }
        }

        // Mise √† jour des donn√©es OHLCV
        function updateOHLCV(newCandle) {
            if (newCandle.isClosed) {
                // Nouveau chandelier ferm√©, l'ajouter √† la liste
                ohlcvData.push(newCandle);
                
                // Garder seulement les 200 derniers
                if (ohlcvData.length > 200) {
                    ohlcvData.shift();
                }
                
                // Mettre √† jour priceData
                priceData.push({
                    time: newCandle.time,
                    price: newCandle.close
                });
                
                if (priceData.length > 200) {
                    priceData.shift();
                }
                
                lastPrice = newCandle.close;
                updateChart();
                
                // Recalculer les indicateurs √† chaque nouveau chandelier ferm√©
                if (botActive && Object.keys(selectedIndicators).length > 0) {
                    calculateIndicators();
                }
            } else {
                // Mettre √† jour le dernier chandelier en cours
                if (ohlcvData.length > 0) {
                    ohlcvData[ohlcvData.length - 1] = newCandle;
                    lastPrice = newCandle.close;
                }
            }
        }

        // Update Price
        function updatePrice(price) {
            const priceElement = document.getElementById('currentPrice');
            const changeElement = document.getElementById('priceChange');
            
            const oldPrice = lastPrice || price;
            priceElement.textContent = `$${price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

            if (oldPrice > 0 && oldPrice !== price) {
                const change = ((price - oldPrice) / oldPrice) * 100;
                changeElement.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                changeElement.className = change >= 0 ? 'change positive' : 'change negative';
            }
            
            lastPrice = price;
        }

        // Calculate Indicators
        function calculateIndicators() {
            if (ohlcvData.length < 30) {
                addLog('Pas assez de donn√©es pour calculer les indicateurs', 'warning');
                return;
            }
            
            const closes = ohlcvData.map(d => d.close);
            const highs = ohlcvData.map(d => d.high);
            const lows = ohlcvData.map(d => d.low);
            const volumes = ohlcvData.map(d => d.volume);
            
            for (const [key, indicator] of Object.entries(selectedIndicators)) {
                try {
                    // R√©cup√©rer les param√®tres depuis les inputs
                    const params = {};
                    for (const paramKey of Object.keys(indicator.params)) {
                        const inputElement = document.getElementById(`${key}-${paramKey}`);
                        if (inputElement) {
                            params[paramKey] = parseFloat(inputElement.value) || indicator.params[paramKey];
                        } else {
                            params[paramKey] = indicator.params[paramKey];
                        }
                    }
                    
                    switch(key) {
                        case 'rsi':
                            indicatorData.rsi = calculateRSI(closes, params.period);
                            break;
                        case 'macd':
                            indicatorData.macd = calculateMACD(closes, params);
                            break;
                        case 'ema':
                            indicatorData.ema = calculateEMA(closes, params.period);
                            break;
                        case 'sma':
                            indicatorData.sma = calculateSMA(closes, params.period);
                            break;
                        case 'bollinger':
                            indicatorData.bollinger = calculateBollingerBands(closes, params);
                            break;
                        case 'stochastic':
                            indicatorData.stochastic = calculateStochastic(highs, lows, closes, params);
                            break;
                        case 'atr':
                            indicatorData.atr = calculateATR(highs, lows, closes, params.period);
                            break;
                        case 'adx':
                            indicatorData.adx = calculateADX(highs, lows, closes, params.period);
                            break;
                        case 'cci':
                            indicatorData.cci = calculateCCI(highs, lows, closes, params.period);
                            break;
                        case 'obv':
                            indicatorData.obv = calculateOBV(closes, volumes);
                            break;
                        case 'vwap':
                            indicatorData.vwap = calculateVWAP(highs, lows, closes, volumes);
                            break;
                        case 'williamsR':
                            indicatorData.williamsR = calculateWilliamsR(highs, lows, closes, params.period);
                            break;
                    }
                } catch (error) {
                    addLog(`Erreur calcul ${key}: ${error.message}`, 'error');
                }
            }

            updateIndicatorDisplay();
            checkTradingSignals();
        }

        // Calculate RSI (Wilder's method)
        function calculateRSI(prices, period) {
            if (prices.length < period + 1) return null;
            
            let gains = [];
            let losses = [];
            
            // Calculer les changements
            for (let i = 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);
            }
            
            // Premier RS avec SMA
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            // Appliquer le smoothing de Wilder
            for (let i = period; i < gains.length; i++) {
                avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
                avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
            }
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));
            
            return rsi.toFixed(2);
        }

        // Calculate MACD
        function calculateMACD(prices, params) {
            const fastEMA = calculateEMAArray(prices, params.fast);
            const slowEMA = calculateEMAArray(prices, params.slow);
            
            if (!fastEMA || !slowEMA || fastEMA.length === 0) return null;
            
            // MACD Line = Fast EMA - Slow EMA
            const macdLine = fastEMA[fastEMA.length - 1] - slowEMA[slowEMA.length - 1];
            
            // Calculate Signal Line (EMA of MACD)
            const macdHistory = [];
            for (let i = 0; i < Math.min(fastEMA.length, slowEMA.length); i++) {
                macdHistory.push(fastEMA[i] - slowEMA[i]);
            }
            
            const signalArray = calculateEMAArray(macdHistory, params.signal);
            const signalLine = signalArray ? signalArray[signalArray.length - 1] : 0;
            
            // Histogram = MACD - Signal
            const histogram = macdLine - signalLine;
            
            return {
                macd: macdLine.toFixed(2),
                signal: signalLine.toFixed(2),
                histogram: histogram.toFixed(2)
            };
        }

        // Calculate EMA Array (returns array of all EMA values)
        function calculateEMAArray(prices, period) {
            if (prices.length < period) return null;
            
            const k = 2 / (period + 1);
            const emaArray = [];
            
            // Premier EMA = SMA
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            emaArray.push(ema);
            
            // Calculer les EMA suivants
            for (let i = period; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
                emaArray.push(ema);
            }
            
            return emaArray;
        }

        // Calculate EMA
        function calculateEMA(prices, period) {
            if (prices.length < period) return null;
            
            const k = 2 / (period + 1);
            let ema = prices[prices.length - period];
            
            for (let i = prices.length - period + 1; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
            }
            
            return ema;
        }

        // Calculate SMA
        function calculateSMA(prices, period) {
            if (prices.length < period) return null;
            
            const slice = prices.slice(-period);
            const sum = slice.reduce((a, b) => a + b, 0);
            
            return (sum / period).toFixed(2);
        }

        // Calculate Bollinger Bands
        function calculateBollingerBands(prices, params) {
            const sma = calculateSMA(prices, params.period);
            if (!sma) return null;
            
            const slice = prices.slice(-params.period);
            const squaredDiffs = slice.map(price => Math.pow(price - sma, 2));
            const variance = squaredDiffs.reduce((a, b) => a + b, 0) / params.period;
            const stdDev = Math.sqrt(variance);
            
            return {
                upper: (parseFloat(sma) + (stdDev * params.stdDev)).toFixed(2),
                middle: sma,
                lower: (parseFloat(sma) - (stdDev * params.stdDev)).toFixed(2)
            };
        }

        // Calculate Stochastic
        function calculateStochastic(highs, lows, closes, params) {
            if (highs.length < params.k) return null;
            
            const period = params.k;
            const sliceHighs = highs.slice(-period);
            const sliceLows = lows.slice(-period);
            const currentClose = closes[closes.length - 1];
            
            const highestHigh = Math.max(...sliceHighs);
            const lowestLow = Math.min(...sliceLows);
            
            // %K = (Current Close - Lowest Low) / (Highest High - Lowest Low) * 100
            let k = 0;
            if (highestHigh !== lowestLow) {
                k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
            }
            
            // %D = SMA of %K (simplified, would need history for proper calculation)
            const d = k; // Simplified, should be 3-period SMA of %K
            
            return {
                k: k.toFixed(2),
                d: d.toFixed(2)
            };
        }

        // Calculate ATR (Average True Range)
        function calculateATR(highs, lows, closes, period) {
            if (highs.length < period + 1) return null;
            
            const trueRanges = [];
            
            for (let i = 1; i < highs.length; i++) {
                const high = highs[i];
                const low = lows[i];
                const prevClose = closes[i - 1];
                
                // True Range = max(high - low, |high - prevClose|, |low - prevClose|)
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                
                trueRanges.push(tr);
            }
            
            // First ATR = SMA of True Ranges
            let atr = trueRanges.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            // Wilder's smoothing
            for (let i = period; i < trueRanges.length; i++) {
                atr = ((atr * (period - 1)) + trueRanges[i]) / period;
            }
            
            return atr.toFixed(2);
        }

        // Calculate ADX (Average Directional Index)
        function calculateADX(highs, lows, closes, period) {
            if (highs.length < period + 1) return null;
            
            // Simplified ADX calculation
            const atr = parseFloat(calculateATR(highs, lows, closes, period));
            const currentRange = highs[highs.length - 1] - lows[lows.length - 1];
            const adx = (currentRange / atr) * 100;
            
            return Math.min(adx, 100).toFixed(2);
        }

        // Calculate CCI (Commodity Channel Index)
        function calculateCCI(highs, lows, closes, period) {
            if (highs.length < period) return null;
            
            // Typical Price = (High + Low + Close) / 3
            const typicalPrices = [];
            for (let i = 0; i < highs.length; i++) {
                typicalPrices.push((highs[i] + lows[i] + closes[i]) / 3);
            }
            
            // SMA of Typical Price
            const sma = calculateSMA(typicalPrices, period);
            if (!sma) return null;
            
            const smaValue = parseFloat(sma);
            const recentTP = typicalPrices.slice(-period);
            
            // Mean Deviation
            const deviations = recentTP.map(tp => Math.abs(tp - smaValue));
            const meanDeviation = deviations.reduce((a, b) => a + b, 0) / period;
            
            // CCI = (Typical Price - SMA) / (0.015 * Mean Deviation)
            const currentTP = typicalPrices[typicalPrices.length - 1];
            const cci = (currentTP - smaValue) / (0.015 * meanDeviation);
            
            return cci.toFixed(2);
        }

        // Calculate OBV (On Balance Volume)
        function calculateOBV(closes, volumes) {
            if (closes.length < 2) return null;
            
            let obv = volumes[0];
            
            for (let i = 1; i < closes.length; i++) {
                if (closes[i] > closes[i - 1]) {
                    obv += volumes[i];
                } else if (closes[i] < closes[i - 1]) {
                    obv -= volumes[i];
                }
                // If equal, OBV doesn't change
            }
            
            return obv.toFixed(0);
        }

        // Calculate VWAP (Volume Weighted Average Price)
        function calculateVWAP(highs, lows, closes, volumes) {
            if (closes.length === 0) return null;
            
            let cumulativeTPV = 0;
            let cumulativeVolume = 0;
            
            for (let i = 0; i < closes.length; i++) {
                const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;
                cumulativeTPV += typicalPrice * volumes[i];
                cumulativeVolume += volumes[i];
            }
            
            const vwap = cumulativeTPV / cumulativeVolume;
            return vwap.toFixed(2);
        }

        // Calculate Williams %R
        function calculateWilliamsR(highs, lows, closes, period) {
            if (highs.length < period) return null;
            
            const recentHighs = highs.slice(-period);
            const recentLows = lows.slice(-period);
            const currentClose = closes[closes.length - 1];
            
            const highestHigh = Math.max(...recentHighs);
            const lowestLow = Math.min(...recentLows);
            
            // Williams %R = (Highest High - Close) / (Highest High - Lowest Low) * -100
            let williamsR = 0;
            if (highestHigh !== lowestLow) {
                williamsR = ((highestHigh - currentClose) / (highestHigh - lowestLow)) * -100;
            }
            
            return williamsR.toFixed(2);
        }

        // Update Indicator Display
        function updateIndicatorDisplay() {
            const container = document.getElementById('indicatorValues');
            container.innerHTML = '';
            
            for (const [key, value] of Object.entries(indicatorData)) {
                const card = document.createElement('div');
                card.className = 'indicator-value-card';
                
                let displayValue = '';
                if (typeof value === 'object') {
                    displayValue = Object.entries(value)
                        .map(([k, v]) => `${k}: ${v}`)
                        .join('<br>');
                } else {
                    displayValue = value;
                }
                
                card.innerHTML = `
                    <div class="label">${availableIndicators[key]?.name || key.toUpperCase()}</div>
                    <div class="value">${displayValue}</div>
                `;
                
                container.appendChild(card);
            }
        }

        // Check Trading Signals
        function checkTradingSignals() {
            if (!botActive) return;
            
            let buySignals = 0;
            let sellSignals = 0;
            let totalIndicators = Object.keys(selectedIndicators).length;
            
            if (totalIndicators === 0) return;
            
            // Check RSI
            if (indicatorData.rsi && selectedIndicators.rsi) {
                const rsi = parseFloat(indicatorData.rsi);
                const oversoldInput = document.getElementById('rsi-oversold');
                const overboughtInput = document.getElementById('rsi-overbought');
                
                const oversold = oversoldInput ? parseFloat(oversoldInput.value) : 30;
                const overbought = overboughtInput ? parseFloat(overboughtInput.value) : 70;
                
                if (rsi < oversold) {
                    buySignals++;
                    addLog(`RSI: ${rsi} < ${oversold} (Survendu) ‚Üí Signal ACHAT`, 'success');
                }
                if (rsi > overbought) {
                    sellSignals++;
                    addLog(`RSI: ${rsi} > ${overbought} (Surachet√©) ‚Üí Signal VENTE`, 'warning');
                }
            }
            
            // Check Stochastic
            if (indicatorData.stochastic && selectedIndicators.stochastic) {
                const k = parseFloat(indicatorData.stochastic.k);
                const oversoldInput = document.getElementById('stochastic-oversold');
                const overboughtInput = document.getElementById('stochastic-overbought');
                
                const oversold = oversoldInput ? parseFloat(oversoldInput.value) : 20;
                const overbought = overboughtInput ? parseFloat(overboughtInput.value) : 80;
                
                if (k < oversold) {
                    buySignals++;
                    addLog(`Stochastic: ${k} < ${oversold} ‚Üí Signal ACHAT`, 'success');
                }
                if (k > overbought) {
                    sellSignals++;
                    addLog(`Stochastic: ${k} > ${overbought} ‚Üí Signal VENTE`, 'warning');
                }
            }
            
            // Check MACD
            if (indicatorData.macd && selectedIndicators.macd) {
                const histogram = parseFloat(indicatorData.macd.histogram);
                
                if (histogram > 0) {
                    buySignals++;
                    addLog(`MACD Histogram: ${histogram} > 0 ‚Üí Signal ACHAT`, 'success');
                }
                if (histogram < 0) {
                    sellSignals++;
                    addLog(`MACD Histogram: ${histogram} < 0 ‚Üí Signal VENTE`, 'warning');
                }
            }
            
            // Check Bollinger Bands
            if (indicatorData.bollinger && selectedIndicators.bollinger) {
                const currentPrice = lastPrice;
                const lower = parseFloat(indicatorData.bollinger.lower);
                const upper = parseFloat(indicatorData.bollinger.upper);
                
                if (currentPrice < lower) {
                    buySignals++;
                    addLog(`Prix ${currentPrice} < Bollinger Lower ${lower} ‚Üí Signal ACHAT`, 'success');
                }
                if (currentPrice > upper) {
                    sellSignals++;
                    addLog(`Prix ${currentPrice} > Bollinger Upper ${upper} ‚Üí Signal VENTE`, 'warning');
                }
            }
            
            // Check Williams %R
            if (indicatorData.williamsR && selectedIndicators.williamsR) {
                const wr = parseFloat(indicatorData.williamsR);
                
                if (wr < -80) {
                    buySignals++;
                    addLog(`Williams %R: ${wr} < -80 (Survendu) ‚Üí Signal ACHAT`, 'success');
                }
                if (wr > -20) {
                    sellSignals++;
                    addLog(`Williams %R: ${wr} > -20 (Surachet√©) ‚Üí Signal VENTE`, 'warning');
                }
            }
            
            // Check CCI
            if (indicatorData.cci && selectedIndicators.cci) {
                const cci = parseFloat(indicatorData.cci);
                
                if (cci < -100) {
                    buySignals++;
                    addLog(`CCI: ${cci} < -100 (Survendu) ‚Üí Signal ACHAT`, 'success');
                }
                if (cci > 100) {
                    sellSignals++;
                    addLog(`CCI: ${cci} > 100 (Surachet√©) ‚Üí Signal VENTE`, 'warning');
                }
            }
            
            // Execute trades based on signals (at least 60% of indicators must agree)
            const buyThreshold = Math.ceil(totalIndicators * 0.6);
            const sellThreshold = Math.ceil(totalIndicators * 0.6);
            
            if (buySignals >= buyThreshold) {
                addLog(`‚ö° ${buySignals}/${totalIndicators} indicateurs ‚Üí SIGNAL D'ACHAT FORT`, 'success');
                executeBuy();
            } else if (sellSignals >= sellThreshold) {
                addLog(`‚ö° ${sellSignals}/${totalIndicators} indicateurs ‚Üí SIGNAL DE VENTE FORT`, 'warning');
                executeSell();
            }
        }

        // Execute Buy
        function executeBuy() {
            const amount = document.getElementById('investAmount').value;
            const currentPrice = parseFloat(document.getElementById('currentPrice').textContent.replace('$', '').replace(',', ''));
            
            addLog(`üü¢ SIGNAL D'ACHAT d√©tect√© √† ${currentPrice}`, 'success');
            addLog(`Montant: ${amount} USDT`, 'success');
            
            updateStatus('positionStatus', 'green');
            document.getElementById('positionText').textContent = 'Long';
            
            // In production, execute actual trade via Binance API
        }

        // Execute Sell
        function executeSell() {
            const currentPrice = parseFloat(document.getElementById('currentPrice').textContent.replace('$', '').replace(',', ''));
            
            addLog(`üî¥ SIGNAL DE VENTE d√©tect√© √† ${currentPrice}`, 'warning');
            
            updateStatus('positionStatus', 'yellow');
            document.getElementById('positionText').textContent = 'Ferm√©e';
            
            // In production, execute actual trade via Binance API
        }

        // Select Trading Pair
        function selectPair(pair) {
            currentPair = pair;
            
            // Update UI
            document.querySelectorAll('.trading-pair-selector button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            addLog(`Paire de trading chang√©e: ${pair}`, 'success');
            
            // Reconnect WebSocket with new pair
            if (binanceWs) {
                connectBinanceWebSocket();
            }
        }

        // Update Trading Mode
        function updateTradingMode() {
            const mode = document.getElementById('tradingMode').value;
            const modeText = mode === 'auto' ? 'Automatique 24/7' : 'Manuel';
            
            document.getElementById('modeText').textContent = modeText;
            addLog(`Mode de trading: ${modeText}`, 'success');
        }

        // Start Bot
        function startBot() {
            if (Object.keys(selectedIndicators).length === 0) {
                addLog('Veuillez s√©lectionner au moins un indicateur', 'error');
                return;
            }
            
            if (!binanceWs || binanceWs.readyState !== WebSocket.OPEN) {
                addLog('Veuillez connecter Binance API d\'abord', 'error');
                return;
            }
            
            botActive = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            updateStatus('modeStatus', 'green');
            
            addLog('üöÄ Bot de trading d√©marr√©', 'success');
            addLog(`Indicateurs actifs: ${Object.keys(selectedIndicators).join(', ')}`, 'success');
        }

        // Stop Bot
        function stopBot() {
            botActive = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            updateStatus('modeStatus', 'yellow');
            document.getElementById('modeText').textContent = 'Manuel';
            
            addLog('‚èπÔ∏è Bot de trading arr√™t√©', 'warning');
        }

        // Initialize Chart
        function initializeChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Prix',
                        data: [],
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }

        // Update Chart
        function updateChart() {
            if (!priceChart) return;
            
            priceChart.data.labels = priceData.map(d => 
                d.time.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})
            );
            priceChart.data.datasets[0].data = priceData.map(d => d.price);
            priceChart.update('none');
        }

        // Update Status
        function updateStatus(elementId, color) {
            const element = document.getElementById(elementId);
            element.className = `status-indicator ${color}`;
        }

        // Add Log Entry
        function addLog(message, type = 'info') {
            const logPanel = document.getElementById('logPanel');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            const time = new Date().toLocaleTimeString('fr-FR');
            entry.textContent = `[${time}] ${message}`;
            
            logPanel.appendChild(entry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        // Request Wake Lock
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    updateStatus('wakeLockStatus', 'green');
                    document.getElementById('wakeLockText').textContent = 'Actif';
                    addLog('Wake Lock activ√©', 'success');
                    
                    wakeLock.addEventListener('release', () => {
                        updateStatus('wakeLockStatus', 'yellow');
                        document.getElementById('wakeLockText').textContent = 'Rel√¢ch√©';
                        addLog('Wake Lock rel√¢ch√©', 'warning');
                    });
                } catch (err) {
                    addLog(`Erreur Wake Lock: ${err.message}`, 'error');
                }
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (binanceWs) {
                binanceWs.close();
            }
            if (wakeLock) {
                wakeLock.release();
            }
        });
    </script>
</body>
</html>
